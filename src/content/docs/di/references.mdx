---
title: Dependency Injection
description: udic references.
---
import { Tabs, TabItem } from '@astrojs/starlight/components';

## Setup
Requires TypeScript 5.4 or newer.

<Tabs syncKey="packageManager">
  <TabItem label="npm" icon="seti:npm">
    ```sh
    npm i udic
    ```
  </TabItem>
  <TabItem label="bun" icon="bun">
    ```sh
    bun i udic
    ```
  </TabItem>
  <TabItem label="pnpm" icon="pnpm">
    ```sh
    pnpm i udic
    ```
  </TabItem>
  <TabItem label="yarn" icon="seti:yarn">
    ```sh
    yarn add udic
    ```
  </TabItem>
</Tabs>

## Create a service
A service contains:
- An unique identifier for injection.
- A type describing possible operations.

```ts
import * as di from 'udic';

// Example service
const createUUID = di.service('createUUID')<
  // Type of the UUID generator
  () => string
>();
```

A service will be optional if the service type includes `undefined`:
```ts
// An optional service
const createUUID = di.service('createUUID')<
  (() => string) | undefined
>();
```

## Using a service
To access the service, use `di.derive` to create a compute based on the service value:
```ts
import * as di from 'udic';

const createUUID = di.service('createUUID')<
  // Type of the UUID generator
  () => string
>();

const getUUID = di.derive(
  [createUUID],
  (createUUID) => {
    // Log the generated UUID
    console.log('Generated UUID:', createUUID());
  }
);
```

A compute can be executed by providing required services implementation.
```ts
getUUID({
  createUUID: () => 'abcd'
});
```

The output of the compute above will be:
```
Generated UUID: abcd
```

## Nesting computes
A compute can be used within another compute.
```ts
import * as di from 'udic';

const number = di.service('number')<number>();

// Calculate a number based on randNumber
const computedNumber = di.derive(
  [number],
  (number) => number + 1
);

const string = di.service('string')<number>();

const computedValue = di.derive(
  // Capture the compute value
  [computedNumber, string],
  (computedNumber, string) => string + (computedNumber * 2)
);

console.log(
  'Computed value:',
  computedValue({
    number: 0,
    string: 'Result:'
  })
);
```

Example output:
```
Result: 2
```

## Provide different implementations
In this example, we can choose to log the number to the console or file.
```ts
import { appendFileSync } from 'node:fs';
import * as di from 'udic';

const randNumber = di.service('randNumber')<() => number>();
const logNumber = di.service('logNumber')<(n: number) => void>();

// Run the compute by providing a
// random number generator implementation
const run = (
  // A compute with dependency 'randNumber' that returns a number
  compute: di.Compute<
    di.InferDependency<typeof randNumber>,
    number
  >
) => compute({
  randNumber: () => 0
});

// Generate a random number and log the
// value using the provided logger
const computeNumber = di.derive(
  [randNumber, logNumber],
  (randNumber, logNumber) => {
    const result = randNumber();
    logNumber(result);
    return result;
  }
);

run(
  // Log generated number to console
  di.inject(computeNumber, {
    logNumber: (n) => {
      console.log('Result:', n);
    }
  })
);

run(
  // Log generated number to a file
  di.inject(computeNumber, {
    logNumber: (n) => {
      appendFileSync('./debug.log', `Result: ${n}`);
    }
  })
);
```

Example output (both `debug.log` & console):
```
Result: 0
```

## Compute caching
Compute results are cached within the same dependencies map.

In this example, `generateNumber` computed result get cached:
```ts
import { derive } from 'udic';

const generateNumber = derive([], () => Math.random());

const processNumber1 = derive([generateNumber], (number) => number * 2);
const processNumber2 = derive([generateNumber], (number) => number * 2);

const validateGeneratedNumber = derive(
  [processNumber1, processNumber2],
  (number1, number2) => number1 === number2
);

console.log(validateGeneratedNumber({})); // true
```

`inject()` creates a child context, so that `inject()` with different dependencies don't use each other cached result.
```ts
import * as di from 'udic';

const id = di.service('id')<string>();
const label = di.service('label')<string>();

const generatedString = di.derive(
  [id],
  (id) => id + ' - ' + Math.random()
);
const result = di.derive(
  [label, generatedString],
  (label, generatedString) => label + ': ' + generatedString
);

const printString = di.derive(
  [
    // Will generate different numbers
    di.inject(result, { id: 'a' }),
    di.inject(result, { id: 'b' })
  ],
  (string1, string2) => {
    console.log(string1);
    console.log(string2);
  }
);

printString({
  label: 'Result'
});
```

Example output:
```
Result: a - 0.12060530798403102
Result: b - 0.6586330037115373
```

It is recommended that your compute is side-effect free to avoid these issues.
